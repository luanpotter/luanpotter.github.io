<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monte Carlo Renderer</title>
  <script src="pixi.min.js"></script>
</head>
<body>
  <script type="text/javascript">
    const type = PIXI.utils.isWebGLSupported() ? 'WebGL' : 'canvas';
    PIXI.utils.sayHello(type);

    const app = new PIXI.Application({
        width: 512,
        height: 512,
        antialias: false,
        transparent: false,
        resolution: 1,
    });

    const game = {
      _lastTime: Date.now(),
      components: [],
      width: 512,
      height: 512,
      constants: {
        alpha: 25000,
      },
    };

    app.ticker.add(delta => gameLoop(game, delta));
    const canvas = new PIXI.Graphics();
    app.stage.addChild(canvas);
    document.body.appendChild(app.view);
    game.canvas = canvas;

    const Point = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      add(p) {
        return new Point(this.x + p.x, this.y + p.y);
      }

      times(m) {
        return new Point(this.x * m, this.y * m);
      }

      squared() {
        return this.x * this.x + this.y * this.y;
      }

      mod() {
        return Math.sqrt(this.squared());
      }
    };

    const Particle = class {
      constructor(game, p, speed) {
        this.game = game;
        this.p = p;
        this.speed = speed;
      }

      update(dt) {
        const modAcc = this.game.constants.alpha / this.p.squared();
        const acc = this.p.times(modAcc / this.p.mod());

        this.p = this.p.add(this.speed.times(dt)).add(acc.times(dt*dt / 2))
        this.speed = this.speed.add(acc.times(dt));
      }

      render(canvas) {
        canvas.lineStyle(2, 0xFFF4E6);
        canvas.drawCircle(this.game.width / 2 + this.p.x, this.game.height /2 + this.p.y, 1);
      }

      destroy() {
        return this.p.x < 0 || this.p.y < 0 || this.p.x > this.game.width || this.p.y > this.game.height;
      }
    };

    const gameLoop = (game, delta) => {
      const time = Date.now();
      const dt = time - game._lastTime;
      game._lastTime = time;
      update(game, dt / 1000);
      render(game);
    };

    const render = game => {
      const { canvas } = game;
      canvas.beginFill(0x3C2F2F);
      canvas.drawRect(0, 0, game.width, game.height);
      canvas.endFill();

      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawCircle(game.width / 2, game.height / 2, 1);

      game.components.forEach(p => p.render(canvas));
    };

    const update = (game, dt) => {
      game.components.forEach(p => p.update(dt));
      game.components = game.components.filter(e => e.destroy());
    };

    game.components.push(new Particle(game, new Point(-512/2, -50), new Point(50, 0)));
  </script>
</body>
</html>
