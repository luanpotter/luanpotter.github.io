<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monte Carlo Renderer</title>
  <script src="pixi.min.js"></script>
  <script src="js/constants.js"></script>
  <script src="js/point.js"></script>
  <script src="js/particle.js"></script>
  <script src="js/button.js"></script>
  <style>
      body {
        background-color: black;
        text-align: center;
      }

      @font-face {
        font-family: diffusion;
        src: url(diffusion.woff2);
      }
  </style>
</head>
<body>
  <script type="text/javascript">
    const type = PIXI.utils.isWebGLSupported() ? 'WebGL' : 'canvas';
    PIXI.utils.sayHello(type);

    const styles = {
      title: new PIXI.TextStyle({
        fontFamily: 'diffusion',
        fontSize: 24,
        fill: '#fff4e6',
      }),
      small: new PIXI.TextStyle({
        fontFamily: 'diffusion',
        fontSize: 12,
        fill: '#fff4e6',
      }),
    };

    const app = new PIXI.Application({
        width: 2*SIZE + MARGIN,
        height: SIZE,
        antialias: false,
        transparent: false,
        resolution: 1,
    });

    const game = {
      _lastTime: Date.now(),
      _lastDt: 0,
      speed: 1,
      repeat: false,
      repeatClock: 0,
      components: [],
      fullWidth: 2*SIZE + MARGIN,
      width: SIZE,
      height: SIZE,
      constants: {
        alpha: 25000,
      },
    };

    const setup = () => {
      const sheet = PIXI.loader.resources['spritesheet'].spritesheet;

      app.ticker.add(delta => gameLoop(game, delta));
      const canvas = new PIXI.Graphics();
      app.stage.addChild(canvas);

      const options = new PIXI.Text('Options', styles.title);
      options.x = SIZE + 2*MARGIN;
      options.y = MARGIN;
      app.stage.addChild(options);

      const time = new PIXI.Text('Time', styles.small);
      time.x = SIZE + 2*MARGIN;
      time.y = MARGIN + options.height + SM;
      app.stage.addChild(time);

      const p = new Point(SIZE + 2*MARGIN, time.y + SM + time.height);
      const d = new Point(16.0 + SM, 0);
      new Button(sheet, p.add(d.times(0)), 'stop', () => game.speed = 0).add(app);
      new Button(sheet, p.add(d.times(1)), 'play', () => game.speed = 1).add(app);
      new Button(sheet, p.add(d.times(2)), 'fast', () => game.speed = 10).add(app);

      const flow = new PIXI.Text('Flow', styles.small);
      flow.x = SIZE + 2*MARGIN;
      flow.y = p.y + SM + 16.0;
      app.stage.addChild(flow);

      const p2 = new Point(SIZE + 2*MARGIN, flow.y + SM + flow.height);
      new Button(sheet, p2.add(d.times(0)), 'pause', () => game.repeat = false).add(app);
      new Button(sheet, p2.add(d.times(1)), 'single', () => game.create()).add(app);
      new Button(sheet, p2.add(d.times(2)), 'repeat', () => game.repeat = true).add(app);

      document.body.appendChild(app.view);
      game.canvas = canvas;
      
      game.create = () => {
        const b = Math.random() * game.height - game.height / 2;
        game.components.push(new Particle(game, new Point(-game.width/2, b), new Point(50, 0)));
      };
    };

    const gameLoop = (game, delta) => {
      const time = Date.now();
      const dt = time - game._lastTime;
      game._lastTime = time;
      update(game, dt / 1000);
      render(game);
    };

    const render = game => {
      const { canvas } = game;

      canvas.beginFill(0x000000);
      canvas.lineStyle(2, 0x000000);
      canvas.drawRect(0, 0, game.fullWidth, game.height);
      canvas.endFill();

      canvas.beginFill(0x3C2F2F);
      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawRect(0, 0, game.width, game.height);
      canvas.drawRect(game.width + MARGIN, 0, game.width, game.height);
      canvas.endFill();

      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawCircle(game.width / 2, game.height / 2, 1);

      game.components.forEach(p => p.render(canvas));
    };

    const update = (game, dt) => {
      if (game.repeat) {
        game.repeatClock += dt;
        while (game.repeatClock > 1) {
          game.repeatClock -= 1;
          game.create();
        }
      } else {
        game.repeatClock = 0;
      }
      dt *= game.speed;
      if (dt === 0) {
        return;
      }
      dt += game._lastDt;
      while (dt >= STEP) {
        game.components.forEach(p => p.update(STEP));
        dt -= STEP;
      }
      game._lastDt = dt;
      game.components = game.components.filter(e => !e.destroy());
    };

    PIXI.loader.add('spritesheet', 'spritesheet.json').load(setup);
  </script>
</body>
</html>
