<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monte Carlo Renderer</title>
  <script src="pixi.min.js"></script>
  <script src="js/constants.js"></script>
  <script src="js/point.js"></script>
  <script src="js/particle.js"></script>
  <script src="js/button.js"></script>
  <style>
      body {
        background-color: black;
        text-align: center;
      }

      @font-face {
        font-family: diffusion;
        src: url(diffusion.woff2);
      }
  </style>
</head>
<body>
  <script type="text/javascript">
    const type = PIXI.utils.isWebGLSupported() ? 'WebGL' : 'canvas';
    PIXI.utils.sayHello(type);

    const style = new PIXI.TextStyle({
      fontFamily: 'diffusion',
      fontSize: 24,
      fill: '#fff4e6',
    });

    const app = new PIXI.Application({
        width: 2*SIZE + MARGIN,
        height: SIZE,
        antialias: false,
        transparent: false,
        resolution: 1,
    });

    const game = {
      _lastTime: Date.now(),
      _lastDt: 0,
      speed: 1,
      components: [],
      fullWidth: 2*SIZE + MARGIN,
      width: SIZE,
      height: SIZE,
      constants: {
        alpha: 25000,
      },
    };

    const setup = () => {
      app.ticker.add(delta => gameLoop(game, delta));
      const canvas = new PIXI.Graphics();
      app.stage.addChild(canvas);

      const options = new PIXI.Text('Options', style);
      options.x = SIZE + 2*MARGIN;
      options.y = MARGIN;
      app.stage.addChild(options);

      const sheet = PIXI.loader.resources['spritesheet'].spritesheet;
      const p = new Point(SIZE + 2*MARGIN, 2*MARGIN + options.height);
      const d = new Point(16.0 + SM, 0);
      new Button(sheet, p.add(d.times(0)), 'stop', () => game.speed = 0).add(app);
      new Button(sheet, p.add(d.times(1)), 'play', () => game.speed = 1).add(app);
      new Button(sheet, p.add(d.times(2)), 'fast', () => game.speed = 10).add(app);

      document.body.appendChild(app.view);
      game.canvas = canvas;

      game.components.push(new Particle(game, new Point(-512/2, -50), new Point(50, 0)));
    };

    const gameLoop = (game, delta) => {
      const time = Date.now();
      const dt = time - game._lastTime;
      game._lastTime = time;
      update(game, dt / 1000);
      render(game);
    };

    const render = game => {
      const { canvas } = game;
      canvas.beginFill(0x3C2F2F);
      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawRect(0, 0, game.width, game.height);
      canvas.drawRect(game.width + MARGIN, 0, game.width, game.height);
      canvas.endFill();

      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawCircle(game.width / 2, game.height / 2, 1);

      game.components.forEach(p => p.render(canvas));
    };

    const update = (game, dt) => {
      dt *= game.speed;
      if (dt === 0) {
        return;
      }
      dt += game._lastDt;
      while (dt >= STEP) {
        game.components.forEach(p => p.update(STEP));
        dt -= STEP;
      }
      game._lastDt = dt;
      game.components = game.components.filter(e => !e.destroy());
    };

    PIXI.loader.add('spritesheet', 'spritesheet.json').load(setup);
  </script>
</body>
</html>
