<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monte Carlo Renderer</title>
  <script src="lib/pixi.min.js"></script>
  <script src="js/constants.js"></script>
  <script src="js/point.js"></script>
  <script src="js/particle.js"></script>
  <script src="js/button.js"></script>
  <script src="js/ui.js"></script>
  <style>
      body {
        background-color: black;
        text-align: center;
      }

      @font-face {
        font-family: diffusion;
        src: url(assets/diffusion.woff2);
      }
  </style>
</head>
<body>
  <script type="text/javascript">
    const type = PIXI.utils.isWebGLSupported() ? 'WebGL' : 'canvas';
    PIXI.utils.sayHello(type);

    const app = new PIXI.Application({
        width: FULL_SIZE,
        height: SIZE,
        antialias: false,
        transparent: false,
        resolution: 1,
    });

    const game = {
      _lastTime: Date.now(),
      _lastDt: 0,
      speed: 1,
      repeat: false,
      repeatClock: 0,
      components: [],
      fullWidth: FULL_SIZE,
      width: SIZE,
      height: SIZE,
      constants: {
        alpha: 25000,
        flow: 1,
      },
    };

    const setup = () => {
      app.ticker.add(delta => gameLoop(game, delta));
      const canvas = new PIXI.Graphics();
      app.stage.addChild(canvas);

      UI(app, game);

      document.body.appendChild(app.view);
      game.canvas = canvas;
      
      game.create = () => {
        const b = Math.random() * game.height - game.height / 2;
        game.components.push(new Particle(game, new Point(-game.width/2, b), new Point(50, 0)));
      };
    };

    const gameLoop = (game, delta) => {
      const time = Date.now();
      const dt = time - game._lastTime;
      game._lastTime = time;
      update(game, dt / 1000);
      render(game);
    };

    const render = game => {
      const { canvas } = game;

      canvas.beginFill(0x000000);
      canvas.lineStyle(2, 0x000000);
      canvas.drawRect(0, 0, game.fullWidth, game.height);
      canvas.endFill();

      canvas.beginFill(0x3C2F2F);
      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawRect(0, 0, game.width, game.height);
      canvas.drawRect(game.width + MARGIN, 0, game.width, game.height);
      canvas.endFill();

      canvas.lineStyle(2, 0xBE9B7B);
      canvas.drawCircle(game.width / 2, game.height / 2, 1);

      game.components.forEach(p => p.render(canvas));
    };

    const update = (game, dt) => {
      dt *= game.speed;
      if (dt === 0) {
        return;
      }

      if (game.repeat) {
        game.repeatClock += dt;
        while (game.repeatClock > 1/game.constants.flow) {
          game.repeatClock -= 1/game.constants.flow;
          game.create();
        }
      } else {
        game.repeatClock = 0;
      }

      dt += game._lastDt;
      while (dt >= STEP) {
        game.components.forEach(p => p.update(STEP));
        dt -= STEP;
      }
      game._lastDt = dt;
      game.components = game.components.filter(e => !e.destroy());
    };

    PIXI.loader.add('sprites', 'assets/spritesheet.json').load(setup);
  </script>
</body>
</html>
